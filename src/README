
# Introduction

#### Features

- Spatial Audio
- Metadata
- Near Field
- High Dynamic Range Peak-Limiter
- Noise-Gate
- Compatible with WebAudio


#### Spatialize Audio

The Core Audio Engine defines a virtual 3D audio space for 2D or 3D applications. Within the virtual audio space are two types of endpoints: (1) sound sources and (2) listeners. Each of these endpoints has a position within the virtual audio space. The audio from each sound source is fed into High Fidelity’s head related transfer function (HRTF) algorithm so each listener hears the sound as if it was generated from the sound source's relative direction and distance to the listener. The web application can set or change the positions of sound sources and listeners, as well as the direction the listener is facing.

Optionally, changes to sound source positions can be synchronized across the network to other instances of the application.

#### Metadata

This library supports tight coupling and a high update-rate for a sound source's positional data. If metadata is enabled, the audio stream from a local sound source will be modified to include the position of the source. A TransportManager will send the modified stream across the network. Other instances of the application will be able to extract the position of the source along with audio-data. This allows for near real-time position updates and avoids any distracting desynchronization between how a source sounds and where its visual representation, such as an avatar of a person talking or the audio from a video, appears to be.

#### Near Field Effects

When a source and listener are within 1 meter of each other, an alternate "near-field" HRTF is used.  This includes a head occlusion algorithm and can help deliver ASMR-like effects.  Nearby audio sources sound convincingly close.

#### High Dynamic Range Peak-Limiter

All audio within this library is handled as 32-bit floats, which allows for an unlimited dynamic range.  This is important in applications where several or many sources may be producing sound at the same time.  More conventional handling of this mixed audio is likely to result in clipping and other artifacts.

Internally, WebRTC uses a 16-bit audio pipeline.  Before audio is sent across the network or delivered to an output device, a specialized look-ahead peak-limiter is applied to do the final compression to 16-bits in a high-quality way.  

When it's time to deliver audio from this library to the application, the higher dynamic-range data must be brought within the expected range. This is the job of the Peak Limiter. It works by looking ahead several frames and quickly adjusting the overall volume of the output stream. This allows the Limiter to cap the loudness of the output without introducing artifacts.  It can handle huge overloads with almost no audible distortion.

#### Noise Gate

The Noise Gate node has an adjustable threshold (or can be disabled).  It can be placed between a microphone's output stream and the TransportManager's sender.  It works by gating, or preventing, any audio that falls below the set loudness threshold.  The Noise Gate eliminates most background noise, frees network resources, and reduces CPU load.  Louder sounds, such as a speaker’s voice, are transmitted clearly.

#### Compatible with WebAudio

The nodes in this package are compatible with standard WebAudio nodes.  They can be arranged as needed to take advantage of WebAudio's flexible modular design.  If all audio sources use 48 kHz, resampling is avoided and the best audio quality will be delivered.

# Installation

use npm somehow

# Getting Started

1. Include Agora's Client Javascript SDK
    ```html
    <script src="AgoraRTC_N-4.12.2.js"></script>
    ```

    More information can be found in Agora's quick-start documentation.
 
2. In the webpage, provide a "Join" button
   ```html
   <button id="join" type="submit" ">Join</button>
   ```

   Some browsers won't allow a web-page to start playing audio unless a user gesture triggers it. Chrome is one example. 

3. In the javascript portion of the web app, include the HiFiAudio library and a TransportManager.

    ```typescript
    import * as HiFiAudio from './hifi-audio.js'
    import { TransportManagerAgora } from "./hifi-transport-agora.js";
    ```

4. Set up callbacks

    To know when other users have joined or departed from the Agora room, register callbacks with the HiFiAudio library:

    ```typescript
    HiFiAudio.on("remote-source-connected", (uid) => { ... });
    HiFiAudio.on("remote-source-disconnected", (uid) => { ... });
    ```

    There are additional callbacks that can be used for more advanced features.
 
5. Call join

   Instantiate a specific TransportManager, and then call join.

    ```typescript
    document.querySelector('join').addEventListener('click', async function() {
        let transport = new TransportManagerAgora(appID, () => { return token; })
        let localUid = transport.generateUniqueID();
        await HiFiAudio.join(transport,
                             localUid,
                             channelName,
                             { x: 2, y: 3, o: 0 }, // initial source position
                             thresholdValue,
                             enableVideo,
                             enableMetaData);
    });
    ```
 
    Calling HiFiAudio.join will connect to an Agora room and wrap the connection with HRTF spatialization.  After joining the room, a source's position can be updated with

    ```typescript
    HiFiAudio.setPosition({ x: ..., y: ..., o: ...})
    ```

    More information about the agoraAppID, agoraToken, and agoraChannelName parameters can be found in Agora's quick-start documentation.
 
6. When finished, call leave

    Once the user's session is complete, disconnect from the Agora channel by calling

    ```typescript
    await HiFiAudio.leave();
    ```
