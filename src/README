
# Introduction

#### Features

- spatial audio
- metadata
- near field
- high dynamic range
- adaptive limiter
- adjustable noise-gate


#### Spatialize Audio

The Core Audio Engine defines a virtual 3D audio space for 2D or 3D applications. Within the virtual audio space are two types of endpoints: (1) sound sources and (2) listeners. Each of these endpoints has a position within the virtual audio space. The audio from each sound source is fed into High Fidelity’s head related transfer function (HRTF) algorithm so each listener hears the sound as if it was generated from the sound source's relative direction and distance to the listener. The web application can set or change the positions of sound sources and listeners, as well as the direction the listener is facing.

Optionally, changes to sound source positions can be synchronized across the network to other instances of the application.

#### Metadata

This library supports tight coupling and a high update-rate for a sound source's positional data. If metadata is enabled, the audio stream from a local sound source will be modified to include the position of the source. A TransportManager will send the modified stream across the network. Other instances of the application will be able to extract the position of the source along with audio-data. This allows for near real-time position updates and avoids any distracting desynchronization between how a source sounds and where its visual representation, such as an avatar of a person talking or the audio from a video, appears to be.

#### Near Field Effects

High Fidelity’s HRTF also adjusts the angle of a sound source to deliver ASMR-like nearfield effects, which means a sound source can appear to be really close to a listener’s ears by adjusting the XXXX -- think about someone whispering into your ear. 

#### High Dynamic Range

All audio within this library is handled as 32-bit floats, which allows for an unlimited dynamic range.  This is important in applications where several or many sources may be producing sound at the same time.  More conventional handling of this mixed audio is likely to result in clipping and other artifacts.

Internally, WebRTC uses a 16-bit audio pipeline.  Before audio is sent across the network, a specialized lookahead peak-limiter is applied to do the final compression to 16-bits in a high-quality way.  This peak-limiter can handle huge overloads with almost no audible distortion.

#### Adaptive Limiter

When it's time to deliver audio from this library to the application, the higher dynamic-range data must be brought within the expected range. This is the job of the Adaptive Limiter. It works by looking ahead several frames and quickly adjusting the overall volume of the output stream. This allows the Adaptive Limiter to cap the loudness of the output without causing distortion or introducing artifacts.

#### Noise Gate

The Noise Gate is adjustable and can be placed between a microphone's output stream and the TransportManager's sender. It works by gating, or preventing, any audio that falls below a set loudness threshold. This eliminates any background noise that is quieter than the set threshold, but allows louder sounds, such as a speaker’s voice, to be transmitted clearly.

# Installation

use npm somehow

# Getting Started

1. Include Agora's Client Javascript SDK
    ```html
    <script src="AgoraRTC_N-4.12.2.js"></script>
    ```

    More information can be found in Agora's quick-start documentation.
 
2. In the webpage, provide a "Join" button
   ```html
   <button id="join" type="submit" ">Join</button>
   ```

   Some browsers won't allow a web-page to start playing audio unless a user gesture triggers it. Chrome is one example. 

3. In the javascript portion of the web app, include the HiFiAudio library and a TransportManager.

    ```typescript
    import * as HiFiAudio from './hifi-audio.js'
    import { TransportManagerAgora } from "./hifi-transport-agora.js";
    ```

4. Set up callbacks

    To know when other users have joined or departed from the Agora room, register callbacks with the HiFiAudio library:

    ```typescript
    HiFiAudio.on("remote-source-connected", (uid) => { ... });
    HiFiAudio.on("remote-source-disconnected", (uid) => { ... });
    ```

    There are additional callbacks that can be used for more advanced features.
 
5. Call join

   Instantiate a specific TransportManager, and then call join.

    ```typescript
    document.querySelector('join').addEventListener('click', async function() {
        let transport = new TransportManagerAgora(appID, () => { return token; })
        let localUid = transport.generateUniqueID();
        await HiFiAudio.join(transport,
                             localUid,
                             channelName,
                             { x: 2, y: 3, z: 0, o: 0 }, // initial character position
                             thresholdValue,
                             enableVideo,
                             enableMetaData);
    });
    ```
 
    Calling HiFiAudio.join will connect to an Agora room and wrap the connection with HRTF spatialization.  After joining the room, a character's position can be updated with

    ```typescript
    HiFiAudio.setPosition({ x: ..., y: ..., z: ..., o: ...})
    ```

    More information about the agoraAppID, agoraToken, and agoraChannelName parameters can be found in Agora's quick-start documentation.
 
6. When finished, call leave

    Once the user's session is complete, disconnect from the Agora channel by calling

    ```typescript
    await HiFiAudio.leave();
    ```
